package com.example.functions.services;

import com.azure.storage.blob.*;
import com.azure.storage.blob.models.*;
import com.azure.data.tables.*;
import com.azure.data.tables.models.*;
import com.microsoft.azure.functions.ExecutionContext;
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FileProcessorService {
    
    // File type constants
    private static final String FILE_TYPE_ADDACS = "ADDACS";
    private static final String FILE_TYPE_ARUDD = "ARUDD";
    
    // Suffix constant for renaming (DFC for both ADDACS and ARUDD)
    private static final String SUFFIX_DFC = "DFC";
    
    // List of file types to process
    private static final List<String> FILE_TYPES = Arrays.asList(
        FILE_TYPE_ADDACS, 
        FILE_TYPE_ARUDD
    );
    
    private final ExecutionContext context;
    private final String storageConnectionString;
    private final Map<String, String> endpointUrls;
    private final TableClient tableClient;
    
    /**
     * Constructor for FileProcessorService
     * @param context Azure Function execution context for logging
     */
    public FileProcessorService(ExecutionContext context) {
        this.context = context;
        this.storageConnectionString = System.getenv("AZURE_STORAGE_CONNECTION_STRING");
        
        // Initialize endpoint URLs for each file type
        this.endpointUrls = new HashMap<>();
        this.endpointUrls.put(FILE_TYPE_ADDACS, System.getenv("ENDPOINT_URL_ADDACS"));
        this.endpointUrls.put(FILE_TYPE_ARUDD, System.getenv("ENDPOINT_URL_ARUDD"));
        
        validateConfiguration();
        
        // Initialize Azure Table Storage client
        this.tableClient = initializeTableClient();
    }
    
    /**
     * Process a file received via HTTP request
     * @param fileName The name of the file
     * @param fileContent The file content as byte array
     * @param fileType The type of file (AUDO, BACO, ADDACS, ARUDD)
     * @return Processing result with success status and details
     */
    public ProcessingResult processHttpFile(String fileName, byte[] fileContent, String fileType) {
        context.getLogger().info("Processing HTTP-submitted file: " + fileName + ", Type: " + fileType);
        
        try {
            // Validate file type
            if (!FILE_TYPES.contains(fileType)) {
                String error = "Invalid file type: " + fileType + ". Must be one of: " + String.join(", ", FILE_TYPES);
                context.getLogger().severe(error);
                logFailureToTableStorage(fileType, fileName, error);
                return new ProcessingResult(false, fileName, null, fileType, error);
            }
            
            // Validate and extract date/sequence from filename
            FileNameComponents components = parseOriginalFileName(fileName);
            if (components == null) {
                String error = "Invalid filename format. Expected: Report_YYYYMMDD_NNNNNN, Received: " + fileName;
                context.getLogger().severe(error);
                logFailureToTableStorage(fileType, fileName, error);
                return new ProcessingResult(false, fileName, null, fileType, error);
            }
            
            context.getLogger().info("Parsed filename - Date: " + components.date + ", Sequence: " + components.sequence);
            
            // Generate new filename based on file type
            String newFileName = generateNewFileName(fileType, components);
            context.getLogger().info("Generated new filename: " + newFileName);
            
            // Upload to Azure Blob Storage
            uploadToBlob(newFileName, fileContent, fileType);
            
            // Log to Azure Table Storage
            logToTableStorage(fileName, newFileName, fileType);
            
            context.getLogger().info("Successfully processed HTTP file: " + newFileName);
            return new ProcessingResult(true, fileName, newFileName, fileType, null);
            
        } catch (Exception e) {
            String error = "Error processing file: " + e.getMessage();
            context.getLogger().severe(error);
            logFailureToTableStorage(fileType, fileName, error);
            return new ProcessingResult(false, fileName, null, fileType, error);
        }
    }
    
    /**
     * Main processing method - downloads files from all endpoints and processes them
     * @return true if all files were processed successfully, false if any failed
     */
    public boolean processAllFiles() {
        context.getLogger().info("FileProcessorService: Starting processing for all file types");
        
        boolean allSuccessful = true;
        int successCount = 0;
        int failureCount = 0;
        
        // Process each file type from its specific endpoint
        for (String fileType : FILE_TYPES) {
            context.getLogger().info("----------------------------------------");
            context.getLogger().info("Processing file type: " + fileType);
            
            try {
                boolean success = processFileFromEndpoint(fileType);
                if (success) {
                    successCount++;
                    context.getLogger().info("Successfully processed " + fileType + " file");
                } else {
                    failureCount++;
                    allSuccessful = false;
                    context.getLogger().warning("Failed to process " + fileType + " file");
                }
            } catch (Exception e) {
                failureCount++;
                allSuccessful = false;
                context.getLogger().severe("Exception processing " + fileType + " file: " + e.getMessage());
                e.printStackTrace();
            }
        }
        
        context.getLogger().info("----------------------------------------");
        context.getLogger().info("Processing complete. Success: " + successCount + ", Failures: " + failureCount);
        
        return allSuccessful;
    }
    
    /**
     * Processes a single file from a specific endpoint
     * @param fileType The type of file to process (AUDO, BACO, ADDACS, ARUDD)
     * @return true if processing was successful, false otherwise
     */
    private boolean processFileFromEndpoint(String fileType) {
        String endpointUrl = endpointUrls.get(fileType);
        context.getLogger().info("Calling endpoint for " + fileType + ": " + endpointUrl);
        
        try {
            // Step 1: Download file from specific endpoint
            FileDownloadResult downloadResult = downloadFileFromEndpoint(endpointUrl, fileType);
            
            if (downloadResult == null || downloadResult.getContent() == null || downloadResult.getContent().length == 0) {
                context.getLogger().warning("No content received from " + fileType + " endpoint");
                logFailureToTableStorage(fileType, null, "No content received from endpoint");
                return false;
            }
            
            // Step 2: Validate and extract date/sequence from original filename
            FileNameComponents components = parseOriginalFileName(downloadResult.getFileName());
            if (components == null) {
                context.getLogger().severe("CRITICAL: Invalid filename format received: " + downloadResult.getFileName());
                context.getLogger().severe("Expected format: Report_YYYYMMDD_NNNNNN");
                context.getLogger().severe("File processing aborted for " + fileType);
                logFailureToTableStorage(fileType, downloadResult.getFileName(), "Invalid filename format");
                return false;
            }
            
            context.getLogger().info("Parsed filename - Date: " + components.date + ", Sequence: " + components.sequence);
            
            // Step 3: Generate new filename based on file type
            String newFileName = generateNewFileName(fileType, components);
            context.getLogger().info("Renamed file from " + downloadResult.getFileName() + " to " + newFileName);
            
            // Step 4: Upload to Azure Blob Storage
            uploadToBlob(newFileName, downloadResult.getContent(), fileType);
            
            // Step 5: Log to Azure Table Storage
            logToTableStorage(downloadResult.getFileName(), newFileName, fileType);
            
            context.getLogger().info("Successfully processed " + fileType + " file: " + newFileName);
            return true;
            
        } catch (Exception e) {
            context.getLogger().severe("Error processing " + fileType + " file: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Initializes the Azure Table Storage client
     */
    private TableClient initializeTableClient() {
        try {
            String tableName = "FileProcessingLog";
            
            // Create table service client
            TableServiceClient tableServiceClient = new TableServiceClientBuilder()
                .connectionString(storageConnectionString)
                .buildClient();
            
            // Create table if it doesn't exist
            try {
                tableServiceClient.createTableIfNotExists(tableName);
                context.getLogger().info("Table '" + tableName + "' is ready for use");
            } catch (Exception e) {
                // Table might already exist, which is fine
                context.getLogger().info("Table '" + tableName + "' already exists or was just created");
            }
            
            // Return client for the specific table
            return tableServiceClient.getTableClient(tableName);
            
        } catch (Exception e) {
            context.getLogger().severe("Error initializing Table Storage client: " + e.getMessage());
            throw new IllegalStateException("Failed to initialize Table Storage", e);
        }
    }
    
    /**
     * Logs file processing details to Azure Table Storage
     */
    private void logToTableStorage(String originalFileName, String updatedFileName, String fileType) {
        try {
            // Create unique partition and row keys
            // Partition key: Date (YYYYMMDD) for efficient querying by date
            // Row key: Timestamp with milliseconds + file type for uniqueness
            String partitionKey = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            String rowKey = LocalDateTime.now().format(DateTimeFormatter.ofPattern("HHmmssSSS")) + "_" + fileType;
            
            // Create table entity with file processing details
            TableEntity entity = new TableEntity(partitionKey, rowKey);
            entity.addProperty("OriginalFileName", originalFileName);
            entity.addProperty("UpdatedFileName", updatedFileName);
            entity.addProperty("FileType", fileType);
            entity.addProperty("TimeReceived", LocalDateTime.now().toString());
            entity.addProperty("ProcessingStatus", "Success");
            entity.addProperty("Suffix", SUFFIX_DFC);
            
            // Add entity to table
            tableClient.createEntity(entity);
            
            context.getLogger().info("Logged file processing to Azure Table Storage - Partition: " + partitionKey + ", Row: " + rowKey);
            
        } catch (Exception e) {
            // Log error but don't fail the entire process
            context.getLogger().severe("Error logging to Table Storage: " + e.getMessage());
            context.getLogger().severe("File was processed successfully but table logging failed");
            // Continue processing - table logging is not critical
        }
    }
    
    /**
     * Logs failed file processing attempts to Azure Table Storage
     */
    private void logFailureToTableStorage(String fileType, String originalFileName, String errorMessage) {
        try {
            String partitionKey = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            String rowKey = LocalDateTime.now().format(DateTimeFormatter.ofPattern("HHmmssSSS")) + "_" + fileType + "_FAILED";
            
            TableEntity entity = new TableEntity(partitionKey, rowKey);
            entity.addProperty("OriginalFileName", originalFileName != null ? originalFileName : "UNKNOWN");
            entity.addProperty("UpdatedFileName", "N/A");
            entity.addProperty("FileType", fileType);
            entity.addProperty("TimeReceived", LocalDateTime.now().toString());
            entity.addProperty("ProcessingStatus", "Failed");
            entity.addProperty("ErrorMessage", errorMessage);
            
            tableClient.createEntity(entity);
            
            context.getLogger().info("Logged failure to Azure Table Storage for " + fileType);
            
        } catch (Exception e) {
            context.getLogger().severe("Error logging failure to Table Storage: " + e.getMessage());
        }
    }
    
    /**
     * Validates that required configuration is present
     */
    private void validateConfiguration() {
        if (storageConnectionString == null || storageConnectionString.isEmpty()) {
            throw new IllegalStateException("AZURE_STORAGE_CONNECTION_STRING environment variable not configured");
        }
        
        // Validate each endpoint URL
        for (String fileType : FILE_TYPES) {
            String url = endpointUrls.get(fileType);
            if (url == null || url.isEmpty()) {
                throw new IllegalStateException("ENDPOINT_URL_" + fileType + " environment variable not configured");
            }
        }
        
        context.getLogger().info("Configuration validated successfully");
        context.getLogger().info("Endpoints configured for: " + String.join(", ", FILE_TYPES));
    }
    
    /**
     * Downloads file from a specific endpoint
     */
    private FileDownloadResult downloadFileFromEndpoint(String endpointUrl, String fileType) throws Exception {
        context.getLogger().info("Downloading " + fileType + " file from: " + endpointUrl);
        
        HttpClient client = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(30))
            .build();
            
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(endpointUrl))
            .timeout(Duration.ofMinutes(2))
            .GET()
            .build();
        
        try {
            HttpResponse<byte[]> response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());
            
            if (response.statusCode() == 200) {
                // Log response headers for debugging
                logResponseHeaders(response, fileType);
                
                // Extract filename from various sources
                String fileName = extractFileName(response, endpointUrl);
                
                if (fileName == null || fileName.isEmpty()) {
                    context.getLogger().severe("FAILED to determine filename for " + fileType + " from any source");
                    return null;
                }
                
                context.getLogger().info("Download complete for " + fileType + " - Filename: " + fileName + 
                                       ", Size: " + response.body().length + " bytes");
                
                return new FileDownloadResult(fileName, response.body());
            } else {
                context.getLogger().severe("Failed to download " + fileType + " file. HTTP Status: " + response.statusCode());
                if (response.body() != null && response.body().length > 0) {
                    context.getLogger().severe("Response body: " + new String(response.body()));
                }
                return null;
            }
        } catch (Exception e) {
            context.getLogger().severe("Error downloading " + fileType + " file: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Parses the original filename to extract date and sequence number
     * Expected format: Report_YYYYMMDD_NNNNNN
     */
    private FileNameComponents parseOriginalFileName(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            return null;
        }
        
        // Remove extension if present
        String nameWithoutExt = fileName;
        int lastDot = fileName.lastIndexOf('.');
        if (lastDot > 0) {
            nameWithoutExt = fileName.substring(0, lastDot);
        }
        
        // Pattern for Report_YYYYMMDD_NNNNNN
        Pattern pattern = Pattern.compile("Report_(\\d{8})_(\\d{6})", Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(nameWithoutExt);
        
        if (matcher.find()) {
            String date = matcher.group(1);
            String sequence = matcher.group(2);
            return new FileNameComponents(date, sequence);
        }
        
        context.getLogger().warning("Filename does not match expected pattern: " + fileName);
        return null;
    }
    
    /**
     * Generates new filename based on file type and extracted components
     * ADDACS/ARUDD: TYPE_DFC_YYYYMMDD_NNNNNN
     */
    private String generateNewFileName(String fileType, FileNameComponents components) {
        // All remaining file types use DFC suffix
        String suffix = SUFFIX_DFC;
        
        // Build new filename: TYPE_SUFFIX_YYYYMMDD_NNNNNN
        return String.format("%s_%s_%s_%s", fileType, suffix, components.date, components.sequence);
    }
    
    /**
     * Attempts to extract filename from multiple sources
     */
    private String extractFileName(HttpResponse<byte[]> response, String endpointUrl) {
        String fileName = null;
        
        // Try Content-Disposition header first
        fileName = extractFileNameFromContentDisposition(response);
        if (fileName != null && !fileName.isEmpty()) {
            context.getLogger().info("Filename found in Content-Disposition header: " + fileName);
            return fileName;
        }
        
        // Try custom headers
        fileName = extractFileNameFromCustomHeader(response);
        if (fileName != null && !fileName.isEmpty()) {
            context.getLogger().info("Filename found in custom header: " + fileName);
            return fileName;
        }
        
        // Try to extract from URL
        fileName = extractFileNameFromUrl(endpointUrl);
        if (fileName != null && !fileName.isEmpty()) {
            context.getLogger().info("Filename extracted from URL: " + fileName);
            return fileName;
        }
        
        return null;
    }
    
    /**
     * Extracts filename from Content-Disposition header
     */
    private String extractFileNameFromContentDisposition(HttpResponse<byte[]> response) {
        String contentDisposition = response.headers()
            .firstValue("Content-Disposition")
            .orElse("");
        
        if (!contentDisposition.isEmpty()) {
            Pattern pattern = Pattern.compile("filename[^;=\\n]*=((['\"]).*?\\2|[^;\\n]*)");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                String fileName = matcher.group(1);
                // Remove quotes if present
                fileName = fileName.replaceAll("[\"]", "");
                return fileName;
            }
        }
        return null;
    }
    
    /**
     * Extracts filename from custom headers
     */
    private String extractFileNameFromCustomHeader(HttpResponse<byte[]> response) {
        // Check X-Filename header
        String fileName = response.headers()
            .firstValue("X-Filename")
            .orElse("");
        
        if (!fileName.isEmpty()) {
            return fileName;
        }
        
        // Check X-File-Name header (alternative naming)
        fileName = response.headers()
            .firstValue("X-File-Name")
            .orElse("");
            
        return fileName.isEmpty() ? null : fileName;
    }
    
    /**
     * Extracts filename from URL path
     */
    private String extractFileNameFromUrl(String url) {
        try {
            String path = URI.create(url).getPath();
            if (path != null && !path.isEmpty()) {
                int lastSlash = path.lastIndexOf('/');
                if (lastSlash >= 0 && lastSlash < path.length() - 1) {
                    return path.substring(lastSlash + 1);
                }
            }
        } catch (Exception e) {
            context.getLogger().warning("Could not extract filename from URL: " + e.getMessage());
        }
        return null;
    }
    
    /**
     * Uploads processed file to Azure Blob Storage
     */
    private void uploadToBlob(String fileName, byte[] content, String fileType) throws Exception {
        context.getLogger().info("Uploading file to blob storage: " + fileName);
        
        try {
            // Determine container based on file type
            String containerName = getContainerName(fileType);
            
            // Create blob service client
            BlobServiceClient blobServiceClient = new BlobServiceClientBuilder()
                .connectionString(storageConnectionString)
                .buildClient();
            
            // Get container client
            BlobContainerClient containerClient = blobServiceClient.getBlobContainerClient(containerName);
            
            // Create container if it doesn't exist
            if (!containerClient.exists()) {
                containerClient.create();
                context.getLogger().info("Created container: " + containerName);
            }
            
            // Get blob client
            BlobClient blobClient = containerClient.getBlobClient(fileName);
            
            // Upload file with overwrite option
            ByteArrayInputStream dataStream = new ByteArrayInputStream(content);
            blobClient.upload(dataStream, content.length, true);
            
            // Set metadata
            Map<String, String> metadata = new HashMap<>();
            metadata.put("fileType", fileType);
            metadata.put("processedTime", LocalDateTime.now().toString());
            metadata.put("originalSize", String.valueOf(content.length));
            metadata.put("suffix", SUFFIX_DFC);
            blobClient.setMetadata(metadata);
            
            context.getLogger().info("Successfully uploaded file to blob storage: " + fileName + 
                                   " in container: " + containerName);
            
        } catch (Exception e) {
            context.getLogger().severe("Error uploading to blob storage: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Determines container name based on file type
     */
    private String getContainerName(String fileType) {
        // You can customize this logic
        // Option 1: All in one container
        return "processed-files";
        
        // Option 2: Separate by suffix type
        // if (fileType.equals(FILE_TYPE_AUDO) || fileType.equals(FILE_TYPE_BACO)) {
        //     return "daf-files";
        // } else {
        //     return "dfc-files";
        // }
    }
    
    /**
     * Logs response headers for debugging
     */
    private void logResponseHeaders(HttpResponse<byte[]> response, String fileType) {
        context.getLogger().info("HTTP Response Headers for " + fileType + ":");
        response.headers().map().forEach((key, value) -> 
            context.getLogger().info("  " + key + ": " + String.join(", ", value))
        );
    }
    
    /**
     * Inner class to hold filename components
     */
    private static class FileNameComponents {
        final String date;
        final String sequence;
        
        FileNameComponents(String date, String sequence) {
            this.date = date;
            this.sequence = sequence;
        }
    }
    
    /**
     * Result class for processing operations
     */
    public static class ProcessingResult {
        private final boolean success;
        private final String originalFileName;
        private final String updatedFileName;
        private final String fileType;
        private final String errorMessage;
        
        public ProcessingResult(boolean success, String originalFileName, String updatedFileName, 
                               String fileType, String errorMessage) {
            this.success = success;
            this.originalFileName = originalFileName;
            this.updatedFileName = updatedFileName;
            this.fileType = fileType;
            this.errorMessage = errorMessage;
        }
        
        public boolean isSuccess() {
            return success;
        }
        
        public String getOriginalFileName() {
            return originalFileName;
        }
        
        public String getUpdatedFileName() {
            return updatedFileName;
        }
        
        public String getFileType() {
            return fileType;
        }
        
        public String getErrorMessage() {
            return errorMessage;
        }
    }
    
    /**
     * Inner class to hold download result
     */
    public static class FileDownloadResult {
        private final String fileName;
        private final byte[] content;
        
        public FileDownloadResult(String fileName, byte[] content) {
            this.fileName = fileName;
            this.content = content;
        }
        
        public String getFileName() {
            return fileName;
        }
        
        public byte[] getContent() {
            return content;
        }
    }
}

-------------------


package com.example.functions;

import com.microsoft.azure.functions.annotation.*;
import com.microsoft.azure.functions.*;
import com.example.functions.services.FileProcessorService;
import java.time.LocalDateTime;
import java.util.Optional;

/**
 * HTTP-triggered Azure Function that processes files sent via HTTP requests
 * This class serves as the entry point for the Azure Function runtime
 * All business logic is delegated to the FileProcessorService
 */
public class FileProcessorFunction {
    
    /**
     * HTTP-triggered Azure Function that processes files sent via POST request
     * @param request HTTP request containing the file data and metadata
     * @param context Execution context for logging and runtime information
     * @return HTTP response indicating success or failure
     */
    @FunctionName("ProcessFile")
    public HttpResponseMessage processFile(
        @HttpTrigger(
            name = "req",
            methods = {HttpMethod.POST},
            authLevel = AuthorizationLevel.FUNCTION,
            route = "files/process"
        ) HttpRequestMessage<Optional<byte[]>> request,
        final ExecutionContext context
    ) {
        context.getLogger().info("========================================");
        context.getLogger().info("FileProcessor HTTP function triggered at: " + LocalDateTime.now());
        context.getLogger().info("========================================");
        
        try {
            // Extract file type from headers or query parameters
            String fileType = getFileType(request, context);
            if (fileType == null || fileType.isEmpty()) {
                String errorMsg = "Missing required parameter: fileType. Must be one of: ADDACS, ARUDD";
                context.getLogger().severe(errorMsg);
                return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                    .body(createErrorResponse(errorMsg))
                    .header("Content-Type", "application/json")
                    .build();
            }
            
            // Extract filename from headers
            String fileName = getFileName(request, context);
            if (fileName == null || fileName.isEmpty()) {
                String errorMsg = "Missing required header: X-Filename or Content-Disposition";
                context.getLogger().severe(errorMsg);
                return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                    .body(createErrorResponse(errorMsg))
                    .header("Content-Type", "application/json")
                    .build();
            }
            
            // Get file content from request body
            Optional<byte[]> bodyOptional = request.getBody();
            if (!bodyOptional.isPresent() || bodyOptional.get().length == 0) {
                String errorMsg = "No file content provided in request body";
                context.getLogger().severe(errorMsg);
                return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                    .body(createErrorResponse(errorMsg))
                    .header("Content-Type", "application/json")
                    .build();
            }
            
            byte[] fileContent = bodyOptional.get();
            context.getLogger().info("Received file: " + fileName + ", Type: " + fileType + 
                                   ", Size: " + fileContent.length + " bytes");
            
            // Create service instance and process the file
            FileProcessorService processorService = new FileProcessorService(context);
            FileProcessorService.ProcessingResult result = processorService.processHttpFile(
                fileName, 
                fileContent, 
                fileType
            );
            
            if (result.isSuccess()) {
                context.getLogger().info("File processed successfully: " + result.getUpdatedFileName());
                return request.createResponseBuilder(HttpStatus.OK)
                    .body(createSuccessResponse(result))
                    .header("Content-Type", "application/json")
                    .build();
            } else {
                context.getLogger().warning("File processing failed: " + result.getErrorMessage());
                return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(createErrorResponse("Processing failed: " + result.getErrorMessage()))
                    .header("Content-Type", "application/json")
                    .build();
            }
            
        } catch (IllegalStateException e) {
            // Configuration errors
            context.getLogger().severe("Configuration error: " + e.getMessage());
            return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("Configuration error: " + e.getMessage()))
                .header("Content-Type", "application/json")
                .build();
            
        } catch (Exception e) {
            // Unexpected errors
            context.getLogger().severe("Unexpected error: " + e.getMessage());
            e.printStackTrace();
            return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("Unexpected error: " + e.getMessage()))
                .header("Content-Type", "application/json")
                .build();
                
        } finally {
            context.getLogger().info("========================================");
            context.getLogger().info("FileProcessor function execution ended at: " + LocalDateTime.now());
            context.getLogger().info("========================================");
        }
    }
    
    /**
     * Batch processing endpoint for multiple files
     * @param request HTTP request to trigger batch processing
     * @param context Execution context
     * @return HTTP response with batch processing results
     */
    @FunctionName("ProcessAllFiles")
    public HttpResponseMessage processAllFiles(
        @HttpTrigger(
            name = "req",
            methods = {HttpMethod.POST, HttpMethod.GET},
            authLevel = AuthorizationLevel.FUNCTION,
            route = "files/process-all"
        ) HttpRequestMessage<Optional<String>> request,
        final ExecutionContext context
    ) {
        context.getLogger().info("========================================");
        context.getLogger().info("Batch FileProcessor triggered at: " + LocalDateTime.now());
        context.getLogger().info("========================================");
        
        try {
            // Create service instance and process all files from configured endpoints
            FileProcessorService processorService = new FileProcessorService(context);
            boolean success = processorService.processAllFiles();
            
            if (success) {
                return request.createResponseBuilder(HttpStatus.OK)
                    .body("{\"status\":\"success\",\"message\":\"All files processed successfully\"}")
                    .header("Content-Type", "application/json")
                    .build();
            } else {
                return request.createResponseBuilder(HttpStatus.PARTIAL_CONTENT)
                    .body("{\"status\":\"partial\",\"message\":\"Some files failed to process. Check logs for details.\"}")
                    .header("Content-Type", "application/json")
                    .build();
            }
            
        } catch (Exception e) {
            context.getLogger().severe("Error in batch processing: " + e.getMessage());
            return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("Batch processing failed: " + e.getMessage()))
                .header("Content-Type", "application/json")
                .build();
        }
    }
    
    /**
     * Extract file type from request (query parameter or header)
     */
    private String getFileType(HttpRequestMessage<Optional<byte[]>> request, ExecutionContext context) {
        // Try query parameter first
        String fileType = request.getQueryParameters().get("fileType");
        if (fileType != null && !fileType.isEmpty()) {
            context.getLogger().info("File type from query parameter: " + fileType);
            return fileType.toUpperCase();
        }
        
        // Try header
        fileType = request.getHeaders().get("x-file-type");
        if (fileType != null && !fileType.isEmpty()) {
            context.getLogger().info("File type from header: " + fileType);
            return fileType.toUpperCase();
        }
        
        return null;
    }
    
    /**
     * Extract filename from request headers
     */
    private String getFileName(HttpRequestMessage<Optional<byte[]>> request, ExecutionContext context) {
        // Try X-Filename header first
        String fileName = request.getHeaders().get("x-filename");
        if (fileName != null && !fileName.isEmpty()) {
            context.getLogger().info("Filename from X-Filename header: " + fileName);
            return fileName;
        }
        
        // Try Content-Disposition header
        String contentDisposition = request.getHeaders().get("content-disposition");
        if (contentDisposition != null && !contentDisposition.isEmpty()) {
            // Parse filename from Content-Disposition
            if (contentDisposition.contains("filename=")) {
                int startIndex = contentDisposition.indexOf("filename=") + 9;
                int endIndex = contentDisposition.indexOf(";", startIndex);
                if (endIndex == -1) {
                    endIndex = contentDisposition.length();
                }
                fileName = contentDisposition.substring(startIndex, endIndex)
                    .replace("\"", "")
                    .trim();
                context.getLogger().info("Filename from Content-Disposition: " + fileName);
                return fileName;
            }
        }
        
        // Try query parameter as last resort
        fileName = request.getQueryParameters().get("filename");
        if (fileName != null && !fileName.isEmpty()) {
            context.getLogger().info("Filename from query parameter: " + fileName);
            return fileName;
        }
        
        return null;
    }
    
    /**
     * Create success response JSON
     */
    private String createSuccessResponse(FileProcessorService.ProcessingResult result) {
        return String.format(
            "{\"status\":\"success\",\"originalFileName\":\"%s\",\"updatedFileName\":\"%s\",\"fileType\":\"%s\",\"message\":\"File processed successfully\"}",
            result.getOriginalFileName(),
            result.getUpdatedFileName(),
            result.getFileType()
        );
    }
    
    /**
     * Create error response JSON
     */
    private String createErrorResponse(String errorMessage) {
        return String.format(
            "{\"status\":\"error\",\"message\":\"%s\"}",
            errorMessage.replace("\"", "\\\"")
        );
    }
}


---------------------------


{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    "FUNCTIONS_WORKER_RUNTIME": "java",
    "AZURE_STORAGE_CONNECTION_STRING": "DefaultEndpointsProtocol=https;AccountName=YOUR_STORAGE_ACCOUNT;AccountKey=YOUR_STORAGE_KEY;EndpointSuffix=core.windows.net",
    "ENDPOINT_URL_ADDACS": "https://your-api-endpoint.com/get-addacs-file",
    "ENDPOINT_URL_ARUDD": "https://your-api-endpoint.com/get-arudd-file",
    "JAVA_HOME": "C:\\Program Files\\Java\\jdk-11",
    "MAIN_CLASS": "com.example.functions.FileProcessorFunction"
  },
  "Host": {
    "LocalHttpPort": 7071,
    "CORS": "*",
    "CORSCredentials": false
  },
  "ConnectionStrings": {}
}




