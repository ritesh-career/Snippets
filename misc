package com.example.functions;

import com.microsoft.azure.functions.annotation.*;
import com.microsoft.azure.functions.*;
import com.example.functions.services.DM6BankingOutputService;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Timer-triggered Azure Function that retrieves and processes files added today
 * Runs every 10 minutes to check for new files in blob storage
 */
public class DM6BankingOutputFunction {
    
    /**
     * Timer-triggered function that runs every 10 minutes
     * Retrieves files added today from blob storage and marks them as pulled
     * @param timerInfo Timer trigger information
     * @param context Execution context for logging
     */
    @FunctionName("RunDM6BankingOutputStream")
    public void run(
        @TimerTrigger(
            name = "dm6Timer", 
            schedule = "0 */10 * * * *"
        ) String timerInfo,
        final ExecutionContext context
    ) {
        context.getLogger().info("========================================");
        context.getLogger().info("DM6 Banking Output Stream triggered at: " + LocalDateTime.now());
        context.getLogger().info("Timer info: " + timerInfo);
        context.getLogger().info("========================================");
        
        try {
            // Create service instance
            DM6BankingOutputService outputService = new DM6BankingOutputService(context);
            
            // Retrieve and process today's files
            DM6BankingOutputService.ProcessingResult result = outputService.retrieveTodaysFiles();
            
            // Log results
            context.getLogger().info("Processing Summary:");
            context.getLogger().info("  Files found today: " + result.getTotalFilesFound());
            context.getLogger().info("  New files pulled: " + result.getFilesRetrieved());
            context.getLogger().info("  Already processed: " + result.getFilesAlreadyProcessed());
            context.getLogger().info("  Failed to process: " + result.getFilesFailed());
            
            // Log file details if any were retrieved
            if (result.getRetrievedFileNames() != null && !result.getRetrievedFileNames().isEmpty()) {
                context.getLogger().info("Files retrieved in this run:");
                for (String fileName : result.getRetrievedFileNames()) {
                    context.getLogger().info("  - " + fileName);
                }
            } else {
                context.getLogger().info("No new files to retrieve in this run");
            }
            
            if (result.isSuccess()) {
                context.getLogger().info("DM6 Banking Output Stream completed successfully");
            } else {
                context.getLogger().warning("DM6 Banking Output Stream completed with some failures");
            }
            
        } catch (IllegalStateException e) {
            // Configuration errors
            context.getLogger().severe("Configuration error in DM6 Banking Output Stream: " + e.getMessage());
            context.getLogger().severe("Please check your Azure Function App Settings");
            e.printStackTrace();
            
        } catch (Exception e) {
            // Unexpected errors
            context.getLogger().severe("Unexpected error in DM6 Banking Output Stream: " + e.getMessage());
            e.printStackTrace();
            
        } finally {
            context.getLogger().info("========================================");
            context.getLogger().info("DM6 Banking Output Stream execution ended at: " + LocalDateTime.now());
            context.getLogger().info("========================================");
        }
    }
    
    /**
     * HTTP endpoint for manual triggering (useful for testing)
     * Allows on-demand execution of the DM6 Banking Output Stream
     */
    @FunctionName("TriggerDM6BankingOutputStream")
    public HttpResponseMessage triggerManually(
        @HttpTrigger(
            name = "req",
            methods = {HttpMethod.POST, HttpMethod.GET},
            authLevel = AuthorizationLevel.FUNCTION,
            route = "dm6/trigger"
        ) HttpRequestMessage<Optional<String>> request,
        final ExecutionContext context
    ) {
        context.getLogger().info("Manual trigger of DM6 Banking Output Stream requested");
        
        try {
            // Create service instance
            DM6BankingOutputService outputService = new DM6BankingOutputService(context);
            
            // Retrieve and process today's files
            DM6BankingOutputService.ProcessingResult result = outputService.retrieveTodaysFiles();
            
            // Create response
            String responseMessage = String.format(
                "{\"status\":\"%s\",\"totalFiles\":%d,\"newFilesPulled\":%d,\"alreadyProcessed\":%d,\"failed\":%d,\"retrievedFiles\":%s}",
                result.isSuccess() ? "success" : "partial",
                result.getTotalFilesFound(),
                result.getFilesRetrieved(),
                result.getFilesAlreadyProcessed(),
                result.getFilesFailed(),
                result.getRetrievedFileNames() != null ? 
                    "\"" + String.join(",", result.getRetrievedFileNames()) + "\"" : "[]"
            );
            
            return request.createResponseBuilder(
                    result.isSuccess() ? HttpStatus.OK : HttpStatus.PARTIAL_CONTENT
                )
                .body(responseMessage)
                .header("Content-Type", "application/json")
                .build();
                
        } catch (Exception e) {
            context.getLogger().severe("Error in manual trigger: " + e.getMessage());
            return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("{\"status\":\"error\",\"message\":\"" + e.getMessage() + "\"}")
                .header("Content-Type", "application/json")
                .build();
        }
    }
}

-----

package com.example.functions.services;

import com.azure.storage.blob.*;
import com.azure.storage.blob.models.*;
import com.microsoft.azure.functions.ExecutionContext;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * Service class for retrieving and processing files from blob storage
 * Handles the DM6 Banking Output Stream logic
 */
public class DM6BankingOutputService {
    
    // Metadata keys for tracking file processing
    private static final String METADATA_PULLED_DATE = "pulledDate";
    private static final String METADATA_PULLED_STATUS = "pulledStatus";
    private static final String METADATA_PULLED_TIME = "pulledTime";
    private static final String METADATA_DM6_PROCESSED = "dm6Processed";
    
    private final ExecutionContext context;
    private final String storageConnectionString;
    private final BlobServiceClient blobServiceClient;
    private final String containerName;
    private final String outputDirectory;
    
    /**
     * Constructor for DM6BankingOutputService
     * @param context Azure Function execution context for logging
     */
    public DM6BankingOutputService(ExecutionContext context) {
        this.context = context;
        this.storageConnectionString = System.getenv("AZURE_STORAGE_CONNECTION_STRING");
        this.containerName = System.getenv("BLOB_CONTAINER_NAME") != null ? 
            System.getenv("BLOB_CONTAINER_NAME") : "processed-files";
        this.outputDirectory = System.getenv("DM6_OUTPUT_DIRECTORY") != null ?
            System.getenv("DM6_OUTPUT_DIRECTORY") : "C:/dm6-output";
        
        validateConfiguration();
        
        // Initialize blob service client
        this.blobServiceClient = new BlobServiceClientBuilder()
            .connectionString(storageConnectionString)
            .buildClient();
            
        // Ensure output directory exists
        ensureOutputDirectory();
    }
    
    /**
     * Retrieves all files added today that haven't been pulled yet
     * @return Processing result with statistics and file names
     */
    public ProcessingResult retrieveTodaysFiles() {
        context.getLogger().info("Starting retrieval of today's files from container: " + containerName);
        
        ProcessingResult result = new ProcessingResult();
        List<String> retrievedFiles = new ArrayList<>();
        
        try {
            // Get container client
            BlobContainerClient containerClient = blobServiceClient.getBlobContainerClient(containerName);
            
            if (!containerClient.exists()) {
                context.getLogger().warning("Container does not exist: " + containerName);
                return result;
            }
            
            // Get today's date for comparison
            LocalDate today = LocalDate.now();
            String todayString = today.format(DateTimeFormatter.ISO_LOCAL_DATE);
            context.getLogger().info("Checking for files added on: " + todayString);
            
            // List all blobs in the container
            for (BlobItem blobItem : containerClient.listBlobs()) {
                String blobName = blobItem.getName();
                result.incrementTotalFiles();
                
                try {
                    // Get blob client
                    BlobClient blobClient = containerClient.getBlobClient(blobName);
                    
                    // Get blob properties and metadata
                    BlobProperties properties = blobClient.getProperties();
                    Map<String, String> metadata = properties.getMetadata();
                    
                    // Check if blob was created today
                    OffsetDateTime lastModified = properties.getLastModified();
                    LocalDate blobDate = lastModified.toLocalDate();
                    
                    if (!blobDate.equals(today)) {
                        context.getLogger().info("Skipping " + blobName + " - not from today (created: " + blobDate + ")");
                        continue;
                    }
                    
                    // Check if already pulled today
                    if (isAlreadyPulledToday(metadata, todayString)) {
                        context.getLogger().info("Skipping " + blobName + " - already pulled today");
                        result.incrementAlreadyProcessed();
                        continue;
                    }
                    
                    // Retrieve the file
                    boolean success = retrieveFile(blobClient, blobName, metadata);
                    
                    if (success) {
                        retrievedFiles.add(blobName);
                        result.incrementRetrieved();
                        context.getLogger().info("Successfully retrieved: " + blobName);
                    } else {
                        result.incrementFailed();
                        context.getLogger().warning("Failed to retrieve: " + blobName);
                    }
                    
                } catch (Exception e) {
                    context.getLogger().severe("Error processing blob " + blobName + ": " + e.getMessage());
                    result.incrementFailed();
                }
            }
            
            result.setRetrievedFileNames(retrievedFiles);
            result.setSuccess(result.getFilesFailed() == 0);
            
        } catch (Exception e) {
            context.getLogger().severe("Error retrieving today's files: " + e.getMessage());
            e.printStackTrace();
            result.setSuccess(false);
        }
        
        return result;
    }
    
    /**
     * Checks if a file has already been pulled today
     */
    private boolean isAlreadyPulledToday(Map<String, String> metadata, String todayString) {
        if (metadata == null) {
            return false;
        }
        
        String pulledDate = metadata.get(METADATA_PULLED_DATE);
        String dm6Processed = metadata.get(METADATA_DM6_PROCESSED);
        
        // Check if pulled date matches today
        return todayString.equals(pulledDate) && "true".equalsIgnoreCase(dm6Processed);
    }
    
    /**
     * Retrieves a file from blob storage and saves it locally
     */
    private boolean retrieveFile(BlobClient blobClient, String blobName, Map<String, String> existingMetadata) {
        try {
            // Download blob content
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            blobClient.downloadStream(outputStream);
            byte[] content = outputStream.toByteArray();
            
            // Save to local file system or process as needed
            String outputPath = saveToLocalFileSystem(blobName, content);
            
            if (outputPath != null) {
                // Update metadata to mark as pulled
                Map<String, String> updatedMetadata = new HashMap<>();
                if (existingMetadata != null) {
                    updatedMetadata.putAll(existingMetadata);
                }
                
                // Add/update pulled metadata
                updatedMetadata.put(METADATA_PULLED_DATE, LocalDate.now().format(DateTimeFormatter.ISO_LOCAL_DATE));
                updatedMetadata.put(METADATA_PULLED_TIME, LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
                updatedMetadata.put(METADATA_PULLED_STATUS, "SUCCESS");
                updatedMetadata.put(METADATA_DM6_PROCESSED, "true");
                
                // Update blob metadata
                blobClient.setMetadata(updatedMetadata);
                
                context.getLogger().info("File saved to: " + outputPath);
                context.getLogger().info("Metadata updated for: " + blobName);
                
                // Optional: Send to DM6 system or perform additional processing
                boolean dm6Success = sendToDM6System(blobName, content);
                if (!dm6Success) {
                    context.getLogger().warning("File retrieved but DM6 processing had issues for: " + blobName);
                }
                
                return true;
            }
            
            return false;
            
        } catch (Exception e) {
            context.getLogger().severe("Error retrieving file " + blobName + ": " + e.getMessage());
            
            // Try to update metadata to indicate failure
            try {
                Map<String, String> failureMetadata = new HashMap<>();
                if (existingMetadata != null) {
                    failureMetadata.putAll(existingMetadata);
                }
                failureMetadata.put(METADATA_PULLED_STATUS, "FAILED");
                failureMetadata.put(METADATA_PULLED_TIME, LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
                blobClient.setMetadata(failureMetadata);
            } catch (Exception metaEx) {
                context.getLogger().warning("Could not update failure metadata: " + metaEx.getMessage());
            }
            
            return false;
        }
    }
    
    /**
     * Saves file content to local file system
     */
    private String saveToLocalFileSystem(String blobName, byte[] content) {
        try {
            // Create date-based subdirectory
            String dateDir = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            File dailyDir = new File(outputDirectory, dateDir);
            if (!dailyDir.exists()) {
                dailyDir.mkdirs();
            }
            
            // Generate output filename with timestamp to avoid collisions
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("HHmmss"));
            String outputFileName = timestamp + "_" + blobName;
            File outputFile = new File(dailyDir, outputFileName);
            
            // Write content to file
            try (FileOutputStream fos = new FileOutputStream(outputFile)) {
                fos.write(content);
                fos.flush();
            }
            
            return outputFile.getAbsolutePath();
            
        } catch (Exception e) {
            context.getLogger().severe("Error saving file to local system: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Sends file to DM6 banking system
     * This is a placeholder - implement actual DM6 integration here
     */
    private boolean sendToDM6System(String fileName, byte[] content) {
        try {
            // TODO: Implement actual DM6 system integration
            // This could be:
            // - HTTP POST to DM6 API
            // - Write to DM6 watched folder
            // - Send to message queue
            // - Direct database insert
            
            context.getLogger().info("DM6 processing placeholder for: " + fileName);
            context.getLogger().info("File size: " + content.length + " bytes");
            
            // For now, just log that we would send to DM6
            // In production, replace with actual integration
            
            return true;
            
        } catch (Exception e) {
            context.getLogger().severe("Error in DM6 processing: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Validates required configuration
     */
    private void validateConfiguration() {
        if (storageConnectionString == null || storageConnectionString.isEmpty()) {
            throw new IllegalStateException("AZURE_STORAGE_CONNECTION_STRING environment variable not configured");
        }
        
        context.getLogger().info("Configuration validated successfully");
        context.getLogger().info("Container: " + containerName);
        context.getLogger().info("Output Directory: " + outputDirectory);
    }
    
    /**
     * Ensures the output directory exists
     */
    private void ensureOutputDirectory() {
        try {
            File dir = new File(outputDirectory);
            if (!dir.exists()) {
                dir.mkdirs();
                context.getLogger().info("Created output directory: " + outputDirectory);
            } else {
                context.getLogger().info("Output directory exists: " + outputDirectory);
            }
        } catch (Exception e) {
            context.getLogger().warning("Could not create output directory: " + e.getMessage());
        }
    }
    
    /**
     * Result class for processing statistics
     */
    public static class ProcessingResult {
        private int totalFilesFound = 0;
        private int filesRetrieved = 0;
        private int filesAlreadyProcessed = 0;
        private int filesFailed = 0;
        private boolean success = true;
        private List<String> retrievedFileNames;
        
        public void incrementTotalFiles() {
            this.totalFilesFound++;
        }
        
        public void incrementRetrieved() {
            this.filesRetrieved++;
        }
        
        public void incrementAlreadyProcessed() {
            this.filesAlreadyProcessed++;
        }
        
        public void incrementFailed() {
            this.filesFailed++;
        }
        
        // Getters and setters
        public int getTotalFilesFound() {
            return totalFilesFound;
        }
        
        public int getFilesRetrieved() {
            return filesRetrieved;
        }
        
        public int getFilesAlreadyProcessed() {
            return filesAlreadyProcessed;
        }
        
        public int getFilesFailed() {
            return filesFailed;
        }
        
        public boolean isSuccess() {
            return success;
        }
        
        public void setSuccess(boolean success) {
            this.success = success;
        }
        
        public List<String> getRetrievedFileNames() {
            return retrievedFileNames;
        }
        
        public void setRetrievedFileNames(List<String> retrievedFileNames) {
            this.retrievedFileNames = retrievedFileNames;
        }
    }
}


-----

{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    "FUNCTIONS_WORKER_RUNTIME": "java",
    "AZURE_STORAGE_CONNECTION_STRING": "DefaultEndpointsProtocol=https;AccountName=YOUR_STORAGE_ACCOUNT;AccountKey=YOUR_STORAGE_KEY;EndpointSuffix=core.windows.net",
    "ENDPOINT_URL_ADDACS": "https://your-api-endpoint.com/get-addacs-file",
    "ENDPOINT_URL_ARUDD": "https://your-api-endpoint.com/get-arudd-file",
    "JAVA_HOME": "C:\\Program Files\\Java\\jdk-11",
    "MAIN_CLASS": "com.example.functions.FileProcessorFunction"
  },
  "Host": {
    "LocalHttpPort": 7071,
    "CORS": "*",
    "CORSCredentials": false
  },
  "ConnectionStrings": {}
}


-----


package com.example.functions.services;

import com.azure.storage.blob.*;
import com.azure.storage.blob.models.*;
import com.microsoft.azure.functions.ExecutionContext;
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FileProcessorService {
    
    // File type constants
    private static final String FILE_TYPE_ADDACS = "ADDACS";
    private static final String FILE_TYPE_ARUDD = "ARUDD";
    
    // Suffix constant for renaming (DFC for both ADDACS and ARUDD)
    private static final String SUFFIX_DFC = "DFC";
    
    // List of file types to process
    private static final List<String> FILE_TYPES = Arrays.asList(
        FILE_TYPE_ADDACS, 
        FILE_TYPE_ARUDD
    );
    
    private final ExecutionContext context;
    private final String storageConnectionString;
    private final Map<String, String> endpointUrls;
    
    /**
     * Constructor for FileProcessorService
     * @param context Azure Function execution context for logging
     */
    public FileProcessorService(ExecutionContext context) {
        this.context = context;
        this.storageConnectionString = System.getenv("AZURE_STORAGE_CONNECTION_STRING");
        
        // Initialize endpoint URLs for each file type
        this.endpointUrls = new HashMap<>();
        this.endpointUrls.put(FILE_TYPE_ADDACS, System.getenv("ENDPOINT_URL_ADDACS"));
        this.endpointUrls.put(FILE_TYPE_ARUDD, System.getenv("ENDPOINT_URL_ARUDD"));
        
        validateConfiguration();
    }
    
    /**
     * Process a file received via HTTP request
     * @param fileName The name of the file
     * @param fileContent The file content as byte array
     * @param fileType The type of file (AUDO, BACO, ADDACS, ARUDD)
     * @return Processing result with success status and details
     */
    public ProcessingResult processHttpFile(String fileName, byte[] fileContent, String fileType) {
        context.getLogger().info("Processing HTTP-submitted file: " + fileName + ", Type: " + fileType);
        
        try {
            // Validate file type
            if (!FILE_TYPES.contains(fileType)) {
                String error = "Invalid file type: " + fileType + ". Must be one of: " + String.join(", ", FILE_TYPES);
                context.getLogger().severe(error);
                return new ProcessingResult(false, fileName, null, fileType, error);
            }
            
            // Validate and extract date/sequence from filename
            FileNameComponents components = parseOriginalFileName(fileName);
            if (components == null) {
                String error = "Invalid filename format. Expected: Report_YYYYMMDD_NNNNNN, Received: " + fileName;
                context.getLogger().severe(error);
                return new ProcessingResult(false, fileName, null, fileType, error);
            }
            
            context.getLogger().info("Parsed filename - Date: " + components.date + ", Sequence: " + components.sequence);
            
            // Generate new filename based on file type
            String newFileName = generateNewFileName(fileType, components);
            context.getLogger().info("Generated new filename: " + newFileName);
            
            // Upload to Azure Blob Storage
            uploadToBlob(newFileName, fileContent, fileType);
            
            context.getLogger().info("Successfully processed HTTP file: " + newFileName);
            return new ProcessingResult(true, fileName, newFileName, fileType, null);
            
        } catch (Exception e) {
            String error = "Error processing file: " + e.getMessage();
            context.getLogger().severe(error);
            return new ProcessingResult(false, fileName, null, fileType, error);
        }
    }
    
    /**
     * Main processing method - downloads files from all endpoints and processes them
     * @return true if all files were processed successfully, false if any failed
     */
    public boolean processAllFiles() {
        context.getLogger().info("FileProcessorService: Starting processing for all file types");
        
        boolean allSuccessful = true;
        int successCount = 0;
        int failureCount = 0;
        
        // Process each file type from its specific endpoint
        for (String fileType : FILE_TYPES) {
            context.getLogger().info("----------------------------------------");
            context.getLogger().info("Processing file type: " + fileType);
            
            try {
                boolean success = processFileFromEndpoint(fileType);
                if (success) {
                    successCount++;
                    context.getLogger().info("Successfully processed " + fileType + " file");
                } else {
                    failureCount++;
                    allSuccessful = false;
                    context.getLogger().warning("Failed to process " + fileType + " file");
                }
            } catch (Exception e) {
                failureCount++;
                allSuccessful = false;
                context.getLogger().severe("Exception processing " + fileType + " file: " + e.getMessage());
                e.printStackTrace();
            }
        }
        
        context.getLogger().info("----------------------------------------");
        context.getLogger().info("Processing complete. Success: " + successCount + ", Failures: " + failureCount);
        
        return allSuccessful;
    }
    
    /**
     * Processes a single file from a specific endpoint
     * @param fileType The type of file to process (AUDO, BACO, ADDACS, ARUDD)
     * @return true if processing was successful, false otherwise
     */
    private boolean processFileFromEndpoint(String fileType) {
        String endpointUrl = endpointUrls.get(fileType);
        context.getLogger().info("Calling endpoint for " + fileType + ": " + endpointUrl);
        
        try {
            // Step 1: Download file from specific endpoint
            FileDownloadResult downloadResult = downloadFileFromEndpoint(endpointUrl, fileType);
            
            if (downloadResult == null || downloadResult.getContent() == null || downloadResult.getContent().length == 0) {
                context.getLogger().warning("No content received from " + fileType + " endpoint");
                return false;
            }
            
            // Step 2: Validate and extract date/sequence from original filename
            FileNameComponents components = parseOriginalFileName(downloadResult.getFileName());
            if (components == null) {
                context.getLogger().severe("CRITICAL: Invalid filename format received: " + downloadResult.getFileName());
                context.getLogger().severe("Expected format: Report_YYYYMMDD_NNNNNN");
                context.getLogger().severe("File processing aborted for " + fileType);
                return false;
            }
            
            context.getLogger().info("Parsed filename - Date: " + components.date + ", Sequence: " + components.sequence);
            
            // Step 3: Generate new filename based on file type
            String newFileName = generateNewFileName(fileType, components);
            context.getLogger().info("Renamed file from " + downloadResult.getFileName() + " to " + newFileName);
            
            // Step 4: Upload to Azure Blob Storage
            uploadToBlob(newFileName, downloadResult.getContent(), fileType);
            
            context.getLogger().info("Successfully processed " + fileType + " file: " + newFileName);
            return true;
            
        } catch (Exception e) {
            context.getLogger().severe("Error processing " + fileType + " file: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Validates that required configuration is present
     */
    private void validateConfiguration() {
        if (storageConnectionString == null || storageConnectionString.isEmpty()) {
            throw new IllegalStateException("AZURE_STORAGE_CONNECTION_STRING environment variable not configured");
        }
        
        // Validate each endpoint URL
        for (String fileType : FILE_TYPES) {
            String url = endpointUrls.get(fileType);
            if (url == null || url.isEmpty()) {
                throw new IllegalStateException("ENDPOINT_URL_" + fileType + " environment variable not configured");
            }
        }
        
        context.getLogger().info("Configuration validated successfully");
        context.getLogger().info("Endpoints configured for: " + String.join(", ", FILE_TYPES));
    }
    
    /**
     * Downloads file from a specific endpoint
     */
    private FileDownloadResult downloadFileFromEndpoint(String endpointUrl, String fileType) throws Exception {
        context.getLogger().info("Downloading " + fileType + " file from: " + endpointUrl);
        
        HttpClient client = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(30))
            .build();
            
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(endpointUrl))
            .timeout(Duration.ofMinutes(2))
            .GET()
            .build();
        
        try {
            HttpResponse<byte[]> response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());
            
            if (response.statusCode() == 200) {
                // Log response headers for debugging
                logResponseHeaders(response, fileType);
                
                // Extract filename from various sources
                String fileName = extractFileName(response, endpointUrl);
                
                if (fileName == null || fileName.isEmpty()) {
                    context.getLogger().severe("FAILED to determine filename for " + fileType + " from any source");
                    return null;
                }
                
                context.getLogger().info("Download complete for " + fileType + " - Filename: " + fileName + 
                                       ", Size: " + response.body().length + " bytes");
                
                return new FileDownloadResult(fileName, response.body());
            } else {
                context.getLogger().severe("Failed to download " + fileType + " file. HTTP Status: " + response.statusCode());
                if (response.body() != null && response.body().length > 0) {
                    context.getLogger().severe("Response body: " + new String(response.body()));
                }
                return null;
            }
        } catch (Exception e) {
            context.getLogger().severe("Error downloading " + fileType + " file: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Parses the original filename to extract date and sequence number
     * Expected format: Report_YYYYMMDD_NNNNNN
     */
    private FileNameComponents parseOriginalFileName(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            return null;
        }
        
        // Remove extension if present
        String nameWithoutExt = fileName;
        int lastDot = fileName.lastIndexOf('.');
        if (lastDot > 0) {
            nameWithoutExt = fileName.substring(0, lastDot);
        }
        
        // Pattern for Report_YYYYMMDD_NNNNNN
        Pattern pattern = Pattern.compile("Report_(\\d{8})_(\\d{6})", Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(nameWithoutExt);
        
        if (matcher.find()) {
            String date = matcher.group(1);
            String sequence = matcher.group(2);
            return new FileNameComponents(date, sequence);
        }
        
        context.getLogger().warning("Filename does not match expected pattern: " + fileName);
        return null;
    }
    
    /**
     * Generates new filename based on file type and extracted components
     * ADDACS/ARUDD: TYPE_DFC_YYYYMMDD_NNNNNN
     */
    private String generateNewFileName(String fileType, FileNameComponents components) {
        // All remaining file types use DFC suffix
        String suffix = SUFFIX_DFC;
        
        // Build new filename: TYPE_SUFFIX_YYYYMMDD_NNNNNN
        return String.format("%s_%s_%s_%s", fileType, suffix, components.date, components.sequence);
    }
    
    /**
     * Attempts to extract filename from multiple sources
     */
    private String extractFileName(HttpResponse<byte[]> response, String endpointUrl) {
        String fileName = null;
        
        // Try Content-Disposition header first
        fileName = extractFileNameFromContentDisposition(response);
        if (fileName != null && !fileName.isEmpty()) {
            context.getLogger().info("Filename found in Content-Disposition header: " + fileName);
            return fileName;
        }
        
        // Try custom headers
        fileName = extractFileNameFromCustomHeader(response);
        if (fileName != null && !fileName.isEmpty()) {
            context.getLogger().info("Filename found in custom header: " + fileName);
            return fileName;
        }
        
        // Try to extract from URL
        fileName = extractFileNameFromUrl(endpointUrl);
        if (fileName != null && !fileName.isEmpty()) {
            context.getLogger().info("Filename extracted from URL: " + fileName);
            return fileName;
        }
        
        return null;
    }
    
    /**
     * Extracts filename from Content-Disposition header
     */
    private String extractFileNameFromContentDisposition(HttpResponse<byte[]> response) {
        String contentDisposition = response.headers()
            .firstValue("Content-Disposition")
            .orElse("");
        
        if (!contentDisposition.isEmpty()) {
            Pattern pattern = Pattern.compile("filename[^;=\\n]*=((['\"]).*?\\2|[^;\\n]*)");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                String fileName = matcher.group(1);
                // Remove quotes if present
                fileName = fileName.replaceAll("[\"]", "");
                return fileName;
            }
        }
        return null;
    }
    
    /**
     * Extracts filename from custom headers
     */
    private String extractFileNameFromCustomHeader(HttpResponse<byte[]> response) {
        // Check X-Filename header
        String fileName = response.headers()
            .firstValue("X-Filename")
            .orElse("");
        
        if (!fileName.isEmpty()) {
            return fileName;
        }
        
        // Check X-File-Name header (alternative naming)
        fileName = response.headers()
            .firstValue("X-File-Name")
            .orElse("");
            
        return fileName.isEmpty() ? null : fileName;
    }
    
    /**
     * Extracts filename from URL path
     */
    private String extractFileNameFromUrl(String url) {
        try {
            String path = URI.create(url).getPath();
            if (path != null && !path.isEmpty()) {
                int lastSlash = path.lastIndexOf('/');
                if (lastSlash >= 0 && lastSlash < path.length() - 1) {
                    return path.substring(lastSlash + 1);
                }
            }
        } catch (Exception e) {
            context.getLogger().warning("Could not extract filename from URL: " + e.getMessage());
        }
        return null;
    }
    
    /**
     * Uploads processed file to Azure Blob Storage
     */
    private void uploadToBlob(String fileName, byte[] content, String fileType) throws Exception {
        context.getLogger().info("Uploading file to blob storage: " + fileName);
        
        try {
            // Determine container based on file type
            String containerName = getContainerName(fileType);
            
            // Create blob service client
            BlobServiceClient blobServiceClient = new BlobServiceClientBuilder()
                .connectionString(storageConnectionString)
                .buildClient();
            
            // Get container client
            BlobContainerClient containerClient = blobServiceClient.getBlobContainerClient(containerName);
            
            // Create container if it doesn't exist
            if (!containerClient.exists()) {
                containerClient.create();
                context.getLogger().info("Created container: " + containerName);
            }
            
            // Get blob client
            BlobClient blobClient = containerClient.getBlobClient(fileName);
            
            // Upload file with overwrite option
            ByteArrayInputStream dataStream = new ByteArrayInputStream(content);
            blobClient.upload(dataStream, content.length, true);
            
            // Set metadata
            Map<String, String> metadata = new HashMap<>();
            metadata.put("fileType", fileType);
            metadata.put("processedTime", LocalDateTime.now().toString());
            metadata.put("originalSize", String.valueOf(content.length));
            metadata.put("suffix", SUFFIX_DFC);
            blobClient.setMetadata(metadata);
            
            context.getLogger().info("Successfully uploaded file to blob storage: " + fileName + 
                                   " in container: " + containerName);
            
        } catch (Exception e) {
            context.getLogger().severe("Error uploading to blob storage: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Determines container name based on file type
     */
    private String getContainerName(String fileType) {
        // You can customize this logic
        // Option 1: All in one container
        return "processed-files";
        
        // Option 2: Separate by suffix type
        // if (fileType.equals(FILE_TYPE_AUDO) || fileType.equals(FILE_TYPE_BACO)) {
        //     return "daf-files";
        // } else {
        //     return "dfc-files";
        // }
    }
    
    /**
     * Logs response headers for debugging
     */
    private void logResponseHeaders(HttpResponse<byte[]> response, String fileType) {
        context.getLogger().info("HTTP Response Headers for " + fileType + ":");
        response.headers().map().forEach((key, value) -> 
            context.getLogger().info("  " + key + ": " + String.join(", ", value))
        );
    }
    
    /**
     * Inner class to hold filename components
     */
    private static class FileNameComponents {
        final String date;
        final String sequence;
        
        FileNameComponents(String date, String sequence) {
            this.date = date;
            this.sequence = sequence;
        }
    }
    
    /**
     * Result class for processing operations
     */
    public static class ProcessingResult {
        private final boolean success;
        private final String originalFileName;
        private final String updatedFileName;
        private final String fileType;
        private final String errorMessage;
        
        public ProcessingResult(boolean success, String originalFileName, String updatedFileName, 
                               String fileType, String errorMessage) {
            this.success = success;
            this.originalFileName = originalFileName;
            this.updatedFileName = updatedFileName;
            this.fileType = fileType;
            this.errorMessage = errorMessage;
        }
        
        public boolean isSuccess() {
            return success;
        }
        
        public String getOriginalFileName() {
            return originalFileName;
        }
        
        public String getUpdatedFileName() {
            return updatedFileName;
        }
        
        public String getFileType() {
            return fileType;
        }
        
        public String getErrorMessage() {
            return errorMessage;
        }
    }
    
    /**
     * Inner class to hold download result
     */
    public static class FileDownloadResult {
        private final String fileName;
        private final byte[] content;
        
        public FileDownloadResult(String fileName, byte[] content) {
            this.fileName = fileName;
            this.content = content;
        }
        
        public String getFileName() {
            return fileName;
        }
        
        public byte[] getContent() {
            return content;
        }
    }
}


-----

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>file-processor-function</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <name>Azure Timer Function - File Processor</name>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <azure.functions.maven.plugin.version>1.24.0</azure.functions.maven.plugin.version>
        <azure.functions.java.library.version>3.0.0</azure.functions.java.library.version>
        <functionAppName>file-processor-function-${build.timestamp}</functionAppName>
        <functionAppRegion>westeurope</functionAppRegion>
        <functionResourceGroup>java-functions-group</functionResourceGroup>
        <functionAppServicePlanName>java-functions-app-service-plan</functionAppServicePlanName>
        <functionPricingTier>B1</functionPricingTier>
        <maven.build.timestamp.format>yyyyMMddHHmmss</maven.build.timestamp.format>
    </properties>

    <dependencies>
        <!-- Azure Functions Java Library -->
        <dependency>
            <groupId>com.microsoft.azure.functions</groupId>
            <artifactId>azure-functions-java-library</artifactId>
            <version>${azure.functions.java.library.version}</version>
        </dependency>
        
        <!-- Azure Storage Blob -->
        <dependency>
            <groupId>com.azure</groupId>
            <artifactId>azure-storage-blob</artifactId>
            <version>12.23.0</version>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
            <version>2.0.9</version>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.9.3</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <version>5.3.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                </configuration>
            </plugin>
            
            <plugin>
                <groupId>com.microsoft.azure</groupId>
                <artifactId>azure-functions-maven-plugin</artifactId>
                <version>${azure.functions.maven.plugin.version}</version>
                <configuration>
                    <appName>${functionAppName}</appName>
                    <resourceGroup>${functionResourceGroup}</resourceGroup>
                    <appServicePlanName>${functionAppServicePlanName}</appServicePlanName>
                    <region>${functionAppRegion}</region>
                    <pricingTier>${functionPricingTier}</pricingTier>
                    <runtime>
                        <os>windows</os>
                        <javaVersion>11</javaVersion>
                    </runtime>
                    <appSettings>
                        <property>
                            <name>FUNCTIONS_EXTENSION_VERSION</name>
                            <value>~4</value>
                        </property>
                        <property>
                            <name>FUNCTIONS_WORKER_RUNTIME</name>
                            <value>java</value>
                        </property>
                        <property>
                            <name>AZURE_STORAGE_CONNECTION_STRING</name>
                            <value>${AZURE_STORAGE_CONNECTION_STRING}</value>
                        </property>
                        <property>
                            <name>FILE_ENDPOINT_BASE_URL</name>
                            <value>${FILE_ENDPOINT_BASE_URL}</value>
                        </property>
                    </appSettings>
                </configuration>
                <executions>
                    <execution>
                        <id>package-functions</id>
                        <goals>
                            <goal>package</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

-----

package com.example.functions;

import com.microsoft.azure.functions.annotation.*;
import com.microsoft.azure.functions.*;
import com.example.functions.services.FileProcessorService;
import java.time.LocalDateTime;
import java.util.Optional;

/**
 * HTTP-triggered Azure Function that processes files sent via HTTP requests
 * This class serves as the entry point for the Azure Function runtime
 * All business logic is delegated to the FileProcessorService
 */
public class FileProcessorFunction {
    
    /**
     * HTTP-triggered Azure Function that processes files sent via POST request
     * @param request HTTP request containing the file data and metadata
     * @param context Execution context for logging and runtime information
     * @return HTTP response indicating success or failure
     */
    @FunctionName("ProcessFile")
    public HttpResponseMessage processFile(
        @HttpTrigger(
            name = "req",
            methods = {HttpMethod.POST},
            authLevel = AuthorizationLevel.FUNCTION,
            route = "files/process"
        ) HttpRequestMessage<Optional<byte[]>> request,
        final ExecutionContext context
    ) {
        context.getLogger().info("========================================");
        context.getLogger().info("FileProcessor HTTP function triggered at: " + LocalDateTime.now());
        context.getLogger().info("========================================");
        
        try {
            // Extract file type from headers or query parameters
            String fileType = getFileType(request, context);
            if (fileType == null || fileType.isEmpty()) {
                String errorMsg = "Missing required parameter: fileType. Must be one of: ADDACS, ARUDD";
                context.getLogger().severe(errorMsg);
                return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                    .body(createErrorResponse(errorMsg))
                    .header("Content-Type", "application/json")
                    .build();
            }
            
            // Extract filename from headers
            String fileName = getFileName(request, context);
            if (fileName == null || fileName.isEmpty()) {
                String errorMsg = "Missing required header: X-Filename or Content-Disposition";
                context.getLogger().severe(errorMsg);
                return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                    .body(createErrorResponse(errorMsg))
                    .header("Content-Type", "application/json")
                    .build();
            }
            
            // Get file content from request body
            Optional<byte[]> bodyOptional = request.getBody();
            if (!bodyOptional.isPresent() || bodyOptional.get().length == 0) {
                String errorMsg = "No file content provided in request body";
                context.getLogger().severe(errorMsg);
                return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                    .body(createErrorResponse(errorMsg))
                    .header("Content-Type", "application/json")
                    .build();
            }
            
            byte[] fileContent = bodyOptional.get();
            context.getLogger().info("Received file: " + fileName + ", Type: " + fileType + 
                                   ", Size: " + fileContent.length + " bytes");
            
            // Create service instance and process the file
            FileProcessorService processorService = new FileProcessorService(context);
            FileProcessorService.ProcessingResult result = processorService.processHttpFile(
                fileName, 
                fileContent, 
                fileType
            );
            
            if (result.isSuccess()) {
                context.getLogger().info("File processed successfully: " + result.getUpdatedFileName());
                return request.createResponseBuilder(HttpStatus.OK)
                    .body(createSuccessResponse(result))
                    .header("Content-Type", "application/json")
                    .build();
            } else {
                context.getLogger().warning("File processing failed: " + result.getErrorMessage());
                return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(createErrorResponse("Processing failed: " + result.getErrorMessage()))
                    .header("Content-Type", "application/json")
                    .build();
            }
            
        } catch (IllegalStateException e) {
            // Configuration errors
            context.getLogger().severe("Configuration error: " + e.getMessage());
            return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("Configuration error: " + e.getMessage()))
                .header("Content-Type", "application/json")
                .build();
            
        } catch (Exception e) {
            // Unexpected errors
            context.getLogger().severe("Unexpected error: " + e.getMessage());
            e.printStackTrace();
            return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("Unexpected error: " + e.getMessage()))
                .header("Content-Type", "application/json")
                .build();
                
        } finally {
            context.getLogger().info("========================================");
            context.getLogger().info("FileProcessor function execution ended at: " + LocalDateTime.now());
            context.getLogger().info("========================================");
        }
    }
    
    /**
     * Batch processing endpoint for multiple files
     * @param request HTTP request to trigger batch processing
     * @param context Execution context
     * @return HTTP response with batch processing results
     */
    @FunctionName("ProcessAllFiles")
    public HttpResponseMessage processAllFiles(
        @HttpTrigger(
            name = "req",
            methods = {HttpMethod.POST, HttpMethod.GET},
            authLevel = AuthorizationLevel.FUNCTION,
            route = "files/process-all"
        ) HttpRequestMessage<Optional<String>> request,
        final ExecutionContext context
    ) {
        context.getLogger().info("========================================");
        context.getLogger().info("Batch FileProcessor triggered at: " + LocalDateTime.now());
        context.getLogger().info("========================================");
        
        try {
            // Create service instance and process all files from configured endpoints
            FileProcessorService processorService = new FileProcessorService(context);
            boolean success = processorService.processAllFiles();
            
            if (success) {
                return request.createResponseBuilder(HttpStatus.OK)
                    .body("{\"status\":\"success\",\"message\":\"All files processed successfully\"}")
                    .header("Content-Type", "application/json")
                    .build();
            } else {
                return request.createResponseBuilder(HttpStatus.PARTIAL_CONTENT)
                    .body("{\"status\":\"partial\",\"message\":\"Some files failed to process. Check logs for details.\"}")
                    .header("Content-Type", "application/json")
                    .build();
            }
            
        } catch (Exception e) {
            context.getLogger().severe("Error in batch processing: " + e.getMessage());
            return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("Batch processing failed: " + e.getMessage()))
                .header("Content-Type", "application/json")
                .build();
        }
    }
    
    /**
     * Extract file type from request (query parameter or header)
     */
    private String getFileType(HttpRequestMessage<Optional<byte[]>> request, ExecutionContext context) {
        // Try query parameter first
        String fileType = request.getQueryParameters().get("fileType");
        if (fileType != null && !fileType.isEmpty()) {
            context.getLogger().info("File type from query parameter: " + fileType);
            return fileType.toUpperCase();
        }
        
        // Try header
        fileType = request.getHeaders().get("x-file-type");
        if (fileType != null && !fileType.isEmpty()) {
            context.getLogger().info("File type from header: " + fileType);
            return fileType.toUpperCase();
        }
        
        return null;
    }
    
    /**
     * Extract filename from request headers
     */
    private String getFileName(HttpRequestMessage<Optional<byte[]>> request, ExecutionContext context) {
        // Try X-Filename header first
        String fileName = request.getHeaders().get("x-filename");
        if (fileName != null && !fileName.isEmpty()) {
            context.getLogger().info("Filename from X-Filename header: " + fileName);
            return fileName;
        }
        
        // Try Content-Disposition header
        String contentDisposition = request.getHeaders().get("content-disposition");
        if (contentDisposition != null && !contentDisposition.isEmpty()) {
            // Parse filename from Content-Disposition
            if (contentDisposition.contains("filename=")) {
                int startIndex = contentDisposition.indexOf("filename=") + 9;
                int endIndex = contentDisposition.indexOf(";", startIndex);
                if (endIndex == -1) {
                    endIndex = contentDisposition.length();
                }
                fileName = contentDisposition.substring(startIndex, endIndex)
                    .replace("\"", "")
                    .trim();
                context.getLogger().info("Filename from Content-Disposition: " + fileName);
                return fileName;
            }
        }
        
        // Try query parameter as last resort
        fileName = request.getQueryParameters().get("filename");
        if (fileName != null && !fileName.isEmpty()) {
            context.getLogger().info("Filename from query parameter: " + fileName);
            return fileName;
        }
        
        return null;
    }
    
    /**
     * Create success response JSON
     */
    private String createSuccessResponse(FileProcessorService.ProcessingResult result) {
        return String.format(
            "{\"status\":\"success\",\"originalFileName\":\"%s\",\"updatedFileName\":\"%s\",\"fileType\":\"%s\",\"message\":\"File processed successfully\"}",
            result.getOriginalFileName(),
            result.getUpdatedFileName(),
            result.getFileType()
        );
    }
    
    /**
     * Create error response JSON
     */
    private String createErrorResponse(String errorMessage) {
        return String.format(
            "{\"status\":\"error\",\"message\":\"%s\"}",
            errorMessage.replace("\"", "\\\"")
        );
    }
}

-----

{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    "FUNCTIONS_WORKER_RUNTIME": "java",
    "AZURE_STORAGE_CONNECTION_STRING": "DefaultEndpointsProtocol=https;AccountName=YOUR_STORAGE_ACCOUNT;AccountKey=YOUR_STORAGE_KEY;EndpointSuffix=core.windows.net",
    "ENDPOINT_URL_ADDACS": "https://your-api-endpoint.com/get-addacs-file",
    "ENDPOINT_URL_ARUDD": "https://your-api-endpoint.com/get-arudd-file",
    "JAVA_HOME": "C:\\Program Files\\Java\\jdk-11",
    "MAIN_CLASS": "com.example.functions.FileProcessorFunction"
  },
  "Host": {
    "LocalHttpPort": 7071,
    "CORS": "*",
    "CORSCredentials": false
  },
  "ConnectionStrings": {}
}



